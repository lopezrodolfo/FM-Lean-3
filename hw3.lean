-- Math 494 Homework #3
-- Rodolfo Lopez

--opens namespaces
open nat
--nat.zero
--nat.succ
open list
--list.nil
--list.cons

-- Recall that the natural numbers are an inductive type generated by
-- zero and succ, so we can define recursive functions on them by
-- matching.  For instance, here is a definition of the "doubling"
-- function by recursion.  Recall that when using the pattern-matching
-- syntax for recursive functions, the recursive argument has to be
-- written on the right of the colon with "ℕ →", and we need
-- parentheses around each left-hand-side pattern.
def double : ℕ → ℕ
| zero := zero
| (succ n) := double n + 2

-- Define the factorial function.  Note that you'll need to delete the
-- ":=" as well as the "sorry" when giving a pattern-matching
-- recursive definition.
def factorial : ℕ → ℕ 
| zero := 1
|(succ n) := (succ n) * factorial n

#eval (factorial 0)
#eval (factorial 3)

-- Here are our definitions of addition and multiplication.  Remember
-- that this is a 2-argument function, but the second argument has to
-- be written as a "ℕ →" to the right of the colon in order to use the
-- pattern-matching syntax for recursive functions.
def myadd (m : ℕ) : ℕ → ℕ
| zero := m
| (succ n) := succ (myadd n)
-- Here "myadd n" means "myadd m n", but we don't pass the parameter m
-- explicitly when calling the function from inside itself because
-- that parameter stays fixed.

def mymult (m : ℕ) : ℕ → ℕ
| zero := zero
| (succ n) := myadd (mymult n) m

-- We won't use these specific functions, though, because addition and
-- multiplication are already defined in the Lean standard library,
-- and given their usual notations "+" and "*".

-- Using these, define exponentiation.
def myexp (m : ℕ) : ℕ → ℕ 
|zero := 1
|(succ n) := mymult (myexp n) m

#eval (myexp 1 0)
#eval (myexp 2 4)

-- We don't have to just match against zero and successor.  For
-- instance, Lean is smart enough to recognize that every natural
-- number is either 0, 1, or of the form n+2 for some natural number
-- n, so it accepts this definition of the Fibonnaci sequence.
def fib : ℕ → ℕ
| 0 := 1
| 1 := 1
| (n+2) := fib (n+1) + fib n

-- Define a function that computes the terms of the Padovan sequence
-- (Google and Wikipedia are your friends).
def padovan : ℕ → ℕ 
| 0 := 1
| 1 := 1
| 2 := 1
|(n+3) := padovan(n+1) + padovan (n) 

#eval (padovan 0) 
#eval (padovan 1) 
#eval (padovan 2) 
#eval (padovan 3) 
#eval (padovan 4) 
#eval (padovan 5) 

-- We can also pattern-match on more than one argument, by putting
-- both on the right-hand side of the colon as "ℕ → ℕ →".  For
-- instance, here is a function that computes binomial coefficients.
-- Note that we have to give a meaning to the binomial coefficient
-- n-choose-k even when k > n; what have we chosen here?  Does that
-- make sense for the combinatorial meaning of binomial coefficients?
def binom : ℕ → ℕ → ℕ
| zero zero := 1
| zero (succ _) := 0
| (succ n) zero := 1
| (succ n) (succ k) := binom n k + binom n (succ k)

-- Similarly, define a function that computes Stirling numbers of the
-- first and second kinds (same remark about Google and Wikipedia --
-- look for "recurrence relation").
def stirling_one : ℕ → ℕ → ℕ 
| zero zero := 1
| n zero := 0
| zero n := 0
| (succ n) (succ k) := n*(stirling_one n (succ k)) + (stirling_one n k)

#eval (stirling_one 0 0)
#eval (stirling_one 1 0)
#eval (stirling_one 0 2)
#eval (stirling_one 8 8)
#eval (stirling_one 2 4)
#eval (stirling_one 5 2)

def stirling_two : ℕ → ℕ → ℕ 
| zero zero := 1
| n zero := 0
| zero n := 0
| (succ n) (succ k) := (succ k)*(stirling_two n (succ k)) + (stirling_two n k)

#eval (stirling_two 0 0)
#eval (stirling_two 1 0)
#eval (stirling_two 0 2)
#eval (stirling_two 8 8)
#eval (stirling_two 2 4)
#eval (stirling_two 5 2)

-- Recall also that for any type A, the type "list A" has constructors
-- [] (the empty list, a.k.a. "nil") and :: (a.k.a. "cons").  For
-- instance, here is a function that concatenates two lists:
def myappend {A : Type} : list A → list A → list A
| [] ys := ys
| (x :: xs) ys := x :: myappend xs ys

-- Try evaluating this on a few lists and make sure you understand how
-- it works.
#eval myappend [1,5,7] [2,3,8]

-- As with addition and multiplication, Lean's standard library
-- predefines concatenation of lists, with the infix notation "++".

#eval [1,5,7] ++ [2,3,8]

-- Define a function that computes the length of a list.
def length {A : Type} : list A → ℕ 
|[] := 0
|(a :: l) := length l + 1

--or could have
--def length'' {A : Type} : list A → ℕ 
--|nil := zero
--|(cons a l) := succ(length l)

--#eval (length [0])
--#eval (length [1,2,3,4])

-- Define a function that adds up all the elements of a list of
-- natural numbers.
def sumlist : list ℕ → ℕ 
| [] := 0
| (n :: l) := n + sumlist l 

--or could have
--def sumlist' : list ℕ → ℕ 
--| nil := zero
--|(cons n l) := n + sumlist l 

#eval (sumlist [])
#eval (sumlist [1,2,3,4])

-- Define a function that squares every element of a list of natural
-- numbers, returing a list of the squares.
def squarelist : list ℕ → list ℕ 
| [] := []
| (n :: l) := [n*n] ++ squarelist l

#eval (squarelist [])
#eval (squarelist [1,2,3,4])

-- Define a function that reverses the order of a list.  (Hint: you
-- may want to use the append "++" operator.)

def reverse {A : Type} : list A → list A 
| [] := []
| (a :: l) := (reverse l) ++ [a]

--#eval (reverse' [0])
--#eval (reverse' [1,2,3])

-- Define a function that takes two lists of natural numbers and adds
-- them up pairwise, so that zipadd [1,5,7] [2,3,8] = [3,8,15].
-- You'll have to decide what to do if the two lists have different
-- lengths (the autograder won't care).
def zipadd : list ℕ → list ℕ → list ℕ 
| [] n := n
| n [] := n
| (x :: xs) (y :: ys) := (x + y) :: zipadd xs ys

#eval (zipadd [] [])
#eval (zipadd [] [2,3,8])
#eval (zipadd [1,5,7] [])
#eval (zipadd [1,5,7] [2,3,8])
#eval (zipadd [1,2,3] [1,2,3,4])


